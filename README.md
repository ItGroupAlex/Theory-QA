# Theoretical questions QA

## Task 1

**1. Тестирование программного обеспечения**   
*— это процесс в рамках жизненного цикла разработки
программного обеспечения, который оценивает качество компонента или системы, а также
связанных с ними рабочих продуктов.* 

**2. Что такое качество программного обеспечения?**    
*Это способность программного продукта при заданных условиях удовлетворять установленным или предполагаемым потребностям.*

**3. Когда начинать и заканчивать тестирование?**    
*Тестирование следует начинать, как только оно становится возможным. Например, тестирование бизнес-требований. Завершать следует тогда, когда его продолжение будет стоить дороже, чем выгоды от него.*

**4. Какие знаете цели тестирования программного обеспечения?**   
*Типичные цели тестирования:*   
* Оценка рабочих продуктов, таких как требования, пользовательские истории, проекты и код.   
* Провоцирование отказов и обнаружение дефектов.   
* Обеспечение необходимого покрытия объекта тестирования.   
* Снижение уровня риска ненадлежащего качества программного обеспечения.   
* Проверка выполнения зафиксированных требований.   
* Проверка того, что объект тестирования соответствует контрактным, юридическим и
нормативным требованиям.  
* Предоставление информации заинтересованным сторонам для принятия обоснованных
решений.  
* Создание уверенности в качестве объекта тестирования.  
* Проверка того, завершен ли объект тестирования и работает ли он так, как ожидают
заинтересованные стороны.  

**5. Quality Assurance- это?**   
*- превентивный подход, ориентированный на процесс, который сосредотачивается на внедрении и улучшении процессов. Он предполагает, что если правильно следовать хорошему процессу, то будет создан хороший продукт. Обеспечение качества применяется как к процессам разработки, так и к процессам тестирования, и за него несет ответственность каждый участник проекта.*

**6. Quality Control - это?**  
*- корректирующий подход, ориентированный на продукт, который сосредотачивается на действиях, поддерживающих достижение надлежащего уровня качества. Тестирование является основным видом контроля качества, в то время как другие виды включают формальные методы (проверку модели и доказательство правильности), моделирование и прототипирование.*

**7. Какие знаете принципы тестирования?**   
* Тестирование демонстрирует наличие дефектов, а не их отсутствие. Тестирование может
показать наличие дефектов в объекте тестирования, но не может доказать их отсутствие (Buxton,
1970). Тестирование снижает вероятность того, что дефекты в объекте тестирования останутся
необнаруженными, но даже если дефекты не были обнаружены, тестирование не доказывает
корректности объекта тестирования.
* Исчерпывающее тестирование невозможно. Полное тестирование с использованием всех
комбинаций вводов и предусловий физически невыполнимо, за исключением тривиальных случаев
(Manna, 1978). Вместо того, чтобы пытаться провести исчерпывающее тестирование, следует
использовать методы тестирования (см. главу 4), расстановку приоритетов тестовых сценариев (см.
раздел 5.1.5) и тестирование, основанное на рисках (см. раздел 5.2), чтобы сосредоточить усилия
по тестированию.
* Раннее тестирование экономит время и деньги. Дефекты, устраненные на ранней стадии
процесса, не вызовут последующих дефектов в производных рабочих продуктах. Стоимость
качества будет снижена, так как позже в ЖЦ ПО будет происходить меньше отказов (Boehm 1981).
Для раннего обнаружения дефектов как можно раньше следует начинать как статическое
тестирование (см. главу 3), так и динамическое тестирование (см. главу 4).
* Кластеризация дефектов. Обычно небольшое количество системных компонентов содержит
большинство обнаруженных дефектов или порождает большинство эксплуатационных отказов.
(Enders, 1975). Это явление является иллюстрацией принципа Парето. Предсказанные и
фактические кластеры дефектов, наблюдаемые в ходе тестирования или эксплуатации, являются
важными входными данными для тестирования, основанного на рисках (см. раздел 5.2).
* Тесты устаревают. Если одни и те же тесты повторяются много раз, они становятся все более
неэффективными в обнаружении новых дефектов (Beizer 1990). Для обнаружения новых дефектов
может потребоваться изменение существующих тестов и тестовых данных, а также написание
новых тестов. Однако в некоторых случаях повторение одних и тех же тестов может иметь
положительный результат, например, при автоматизированном регрессионном тестировании (см.
раздел 2.2.3).
* Тестирование зависит от контекста. Не существует единого универсального подхода к
тестированию. Тестирование выполняется по-разному в зависимости от контекста (Kaner 2011).
* Заблуждение об отсутствии дефектов. Было бы ошибкой ожидать, что верификация
программного обеспечения обеспечит успех системы. Тщательное тестирование всех указанных
требований и исправление всех обнаруженных дефектов может привести к созданию системы,
которая не будет соответствовать потребностям и ожиданиям пользователей, не будет помогать в
достижении бизнес-целей заказчика и будет уступать другим конкурирующим системам. Также в
дополнение к верификации следует проводить валидацию (Boehm 1981).
    
**8. Что такое верификация?**   
Это проверка того, соответствует ли система заданным требованиям.

**9. Что такое валидация?**   
Это проверка того, соответствует ли система потребностям пользователей и других заинтересованных сторон в ее операционной среде.

**10. Перечислите характеристики качества программного обеспечения и их атрибуты.**   
* Производительность  
    + Эффективность использования ресурсов (Resource Utilization): Этот атрибут оценивает, насколько эффективно программа использует ресурсы, такие как память, процессорное время и сетевая пропускная способность. Высокая эффективность обеспечивает оптимальное использование ресурсов.  
    + Время отклика (Response Time): Время отклика измеряет, сколько времени требуется программе для реагирования на запросы пользователя. Снижение времени отклика повышает удовлетворенность пользователей.  
    + Пропускная способность (Throughput): Пропускная способность определяет, сколько операций программа может обработать за единицу времени. Высокая пропускная способность важна для приложений с большой нагрузкой.  
* Совместимость
    + Совместимость с платформами (Platform Compatibility): Этот атрибут оценивает способность программы работать на различных операционных системах и аппаратных платформах. Совместимость важна для программ, предназначенных для разных сред.
    + Совместимость с браузерами (Browser Compatibility): Совместимость с разными веб-браузерами важна для веб-приложений, чтобы они корректно отображались и функционировали в разных браузерах.
    + Совместимость с операционными системами (Operating System Compatibility): Этот атрибут оценивает способность программы работать на разных версиях операционных систем, что важно для пользователей с разными ОС.
* Удобство использования
    + Понимаемость (Understandability): Понимаемость оценивает, насколько легко пользователи могут понять, как использовать программу. Простой и понятный интерфейс повышает удобство использования.
    + Простота обучения (Learnability): Этот атрибут связан с легкостью освоения программы новыми пользователями. Чем быстрее пользователи могут освоить программу, тем лучше.
    + Ориентация на пользователя (User-Centered Design): Удовлетворение потребностей и ожиданий пользователей является ключевой составляющей удобства использования.
* Надежность  
    + Доступность (Availability): Этот атрибут измеряет время, в течение которого система доступна для использования. Надежная система должна иметь высокую доступность, чтобы минимизировать простои.  
    + Устойчивость (Fault Tolerance): Устойчивость оценивает способность программы работать надежно, даже если возникают сбои или ошибки. Надежные программы могут продолжать функционировать, даже если произошел сбой.  
    + Устойчивость (Resilience): Этот атрибут связан с способностью программы восстанавливаться после сбоев и неполадок. Восстановление может включать в себя восстановление данных или переключение на резервные ресурсы.  
    + Предсказуемость (Predictability): Надежная система должна предсказуемо вести себя в различных ситуациях, что важно для пользователей и операторов системы.  
* Безопасность
    + Конфиденциальность (Confidentiality): Этот атрибут оценивает способность программы защищать конфиденциальные данные от несанкционированного доступа. Высокая конфиденциальность важна для систем, которые обрабатывают чувствительные данные.
    + Целостность (Integrity): Способность программы обеспечивать целостность данных и защищать их от несанкционированных изменений. Например, если данные не должны быть подвергнуты изменениям без авторизации, целостность играет важную роль.
    + Доступность (Availability): Этот атрибут определяет способность программы оставаться доступной даже при атаках или сбоях. Надежные системы должны быть доступными для пользователей даже в условиях неполадок.
* Сопровождаемость
    + Модульность (Modularity): Модульность оценивает способность программы быть разбитой на отдельные модули, что облегчает сопровождение и поддержку. Модульные системы позволяют быстрее вносить изменения и устранять ошибки.
    + Изменяемость (Changeability): Изменяемость определяет, насколько легко программа может подвергаться изменениям без существенных нарушений работы. Поддерживаемость связана с управлением изменениями в программе.
    + Документация (Documentation): Наличие подробной и актуальной документации для пользователей и разработчиков оказывает значительное влияние на поддерживаемость и сопровождаемость программы.
* Переносимость
    + Бинарная: Бинарная переносимость предполагает возможность запуска приложения в виде исполняемого модуля на нескольких платформах. Бинарная переносимость приложения ограничивается набором очень схожих целевых платформ, совместимых на уровне API и двоичных (бинарных) интерфейсов приложений.
    + Уровня исходного кода: Переносимость приложения на уровне исходного кода обеспечивается за счет возможности его компиляции для заданного целевого окружения без существенных затрат на адаптацию. Под существенными затратами на адаптацию следует понимать объем работы, сопоставимый с повторной разработкой приложения для заданной целевой платформы. Показательным примером является семейство операционных систем (ОС) UNIX. После того, как системное ядро было реализовано на языке Си без использования платфор-менно-зависимого языка ассемблера, ОС UNIX была адаптирована для множества аппаратных архитектур. Однако адаптации также способствовала модульная архитектура ОС UNIX, позволяющая вносить изменения строго в платформенно-зависимые компоненты, не затрагивая других.
 
  ## Task 2
  
  ## Task 3

  ## Task 4
